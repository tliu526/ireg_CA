/*
Implementation of the Voronoi Grid Generator. Actual implementation may use Fortune's Algorithm.
Currently, the Voronoi diagram is built by reading in the data file generated by the Delaunay
Grid Generator.

(c) 2015 Tony Liu.
*/

#include "VoronoiGridGenerator.h"


#include <fstream>
#include <sstream>
#include <iostream>
#include <cstdlib>
#include <algorithm>

using namespace std;

VoronoiGridGenerator::VoronoiGridGenerator(string file){
	grid_type = "Voronoi";

	string line, name;
	istringstream iss;
	ifstream in(file);
	
	//Check if correct input data type
	getline(in, line);
	iss.str(line);
	iss.clear();
	iss >> name;

	//ifstream.close();
	
	if(name.compare("Delaunay") == 0){
		init_from_file(file); //reads in file
		init_from_delaunay();			
	}
	else{
		cout << "Incorrect input file" << endl;
	}
}

void VoronoiGridGenerator::init_from_delaunay(){
	//initialize pt_face_map for fast voronoi face generation
	typename map<string, Poly>::iterator map_it;
	for(map_it = face_map.begin(); map_it != face_map.end(); map_it++) {
		Poly face = map_it->second;
		string f_name = map_it->first;

		for (int i = 0; i < face.edges.size(); i++){
			Edge e = face.edges[i];
			//want the point or the label of the point?
			vector<string> *p_vec = &pt_face_map[rev_vert_map[e.p]];
			vector<string> *q_vec = &pt_face_map[rev_vert_map[e.q]];
			
			if(count(p_vec->begin(), p_vec->end(), f_name) == 0){
				p_vec->push_back(f_name);				
			}

			if(count(q_vec->begin(), q_vec->end(), f_name) == 0){
				q_vec->push_back(f_name);				
			}
		}
	}
	//Now, build up voronoi diagram from circumcenters of triangles
	init_borders();
	init_voronoi();

	//worries about overwriting rev_gen_pts_map
	init_maps();
}

void VoronoiGridGenerator::init_borders(){
	//TODO standardize
	min_x -= 10;
	min_y -= 10;
	max_x += 10;
	max_y += 10;

	top_border = Edge(Point(min_x, max_y), Point(max_x, max_y));
	bottom_border = Edge(Point(min_x, min_y), Point(max_x, min_y));
	left_border = Edge(Point(min_x, min_y), Point(min_x, max_y));
	right_border = Edge(Point(max_x, min_y), Point(max_x, max_y));
}

void VoronoiGridGenerator::init_voronoi(){
	verts.clear();
	rev_vert_map.clear();
	vector<Edge> new_edges;
	vector<Poly> new_faces;

	typename map<string, vector<string> >::iterator map_it;
	for(map_it = pt_face_map.begin(); map_it != pt_face_map.end(); map_it++){

		vector<string> adj_faces = map_it->second;
		vector<Edge> face_edges;

		for(int i = 0; i < adj_faces.size(); i++){
			Tri *t1 = (Tri*)&face_map[adj_faces[i]];
			Point v1 = get_circumcenter(*t1);
			
			//build up the edges of the Voronoi polygon
			for(int j = 0; j < adj_faces.size(); j++){
				if(i != j){
					Tri *t2 = (Tri*)&face_map[adj_faces[j]];	
					if(t2->shares_edge(*t1)){
						//Point v2 = clamp_pt(get_circumcenter(t2));
						Point v2 = get_circumcenter(*t2);
						Edge e = clamp_edge(Edge(v1, v2));
						//Edge e = Edge(v1, v2);
						if(e.p != e.q){
							if(count(verts.begin(), verts.end(), e.p) == 0){
								verts.push_back(e.p);
							}

							if(count(verts.begin(), verts.end(), e.q) == 0){
								verts.push_back(e.q);
							}						

							if(count(face_edges.begin(), face_edges.end(), e) == 0){
								face_edges.push_back(e);
							}
						}
					}
				}
			}
		}

		add_border_edge(face_edges);
		Poly new_face(face_edges);
		
		//TODO this makes the face generation incomplete, need a better way 
		//to handle border cases
		if(new_face.is_valid_poly()){
			for(int i = 0; i < face_edges.size(); i++){
				if(count(new_edges.begin(), new_edges.end(), face_edges[i]) == 0){
					new_edges.push_back(face_edges[i]);
				}
			}	
			new_faces.push_back(Poly(face_edges));
		}
		else {
			//TODO degeneracy with gen_pts
		}
	}

	//clear data from delaunay initialization
	faces.clear();
	face_map.clear();
	faces = new_faces;

	edges.clear();
	edges = new_edges;
	edge_map.clear();
	
	rev_edge_map.clear();
	pt_map.clear();
	rev_vert_map.clear();
}

//TODO instead of a straight clamp, calculate equation for line and then clamp at border
Point VoronoiGridGenerator::clamp_pt(Point p){
	float x, y;
	
	x = max(min(max_x+100, p.x), min_x-100);
	y = max(min(max_y+100, p.y), min_y-100);

	return Point(x,y);
}

Edge VoronoiGridGenerator::clamp_edge(Edge e){
	//case 1: both ends in boundary
	if(pt_in_grid(e.q) && pt_in_grid(e.p)){
		return e;
	}
	//case 2: one end in boundary
	else if(pt_in_grid(e.q) || pt_in_grid(e.p)){
		Point border_pt;
		pair<float, float> line_params;
		line_params = (get_line(e.q, e.p));

		if(edge_intersect(top_border, e)) border_pt = eval_at_border(line_params, top_border);
		else if(edge_intersect(bottom_border, e)) border_pt = eval_at_border(line_params, bottom_border);
		else if(edge_intersect(left_border, e)) border_pt = eval_at_border(line_params, left_border);
		else if(edge_intersect(right_border, e)) border_pt = eval_at_border(line_params, right_border);

		if(pt_in_grid(e.q)){
			return Edge(e.q, border_pt);
		}
		else {
			return Edge(e.p, border_pt);
		}
	}
	//case 3: both ends out of the boundary
	else {
		Point border_pt;
		pair<float, float> line_params;
		line_params = (get_line(e.q, e.p));
		border_pt = eval_at_border(line_params, closest_border(e));
		return Edge(border_pt, border_pt); //we're returning a self edge
	}
}

void VoronoiGridGenerator::add_border_edge(vector<Edge> &edges){
	Point *p1 = NULL;
	Point *p2 = NULL;
	for(int i = 0; i < edges.size(); i++){
		Edge e = edges[i];
		if(!pt_in_grid(e.p)){
			p1 = &e.p;
			break;
		}

		if(!pt_in_grid(e.q)){
			p1 = &e.q;
			break;
		}
	}
	if(p1 != NULL){
		for(int i = 0; i < edges.size(); i++){
			Edge e = edges[i];
			if((e.p != *p1) && !pt_in_grid(e.p)){
				p2 = &e.p;
				break;
			}

			if((e.q != *p1) && !pt_in_grid(e.q)){
				p2 = &e.q;
				break;
			}
		}
		if(p2 != NULL){
			edges.push_back(Edge(*p1,*p2));
		}
	}	
}

//pre: border is one of the grid borders
Point VoronoiGridGenerator::eval_at_border(pair<float, float> line_params, Edge border) {
	//L/R border
	if(border.p.x == border.q.x){
		float y = (line_params.first * border.p.x) + line_params.second;
		return Point(border.p.x, y);
	}
	//T/D border
	else {
		float x = (border.p.y - line_params.second) / line_params.first;
		return Point(x, border.p.y);
	}
	
}

//pre: Edge e has both points outside the grid
Edge VoronoiGridGenerator::closest_border(Edge e){
	if((e.q.y > max_y) && (e.p.y > max_y)) return top_border;
	if((e.q.y < min_y) && (e.p.y < min_y)) return bottom_border;
	if((e.q.x < min_x) && (e.p.x < min_x)) return left_border;
	if((e.q.x > max_x) && (e.p.x > max_x)) return right_border;

	//shouldn't get here
	return top_border;
}

void VoronoiGridGenerator::generate_graph(){}

/*
int main(){
	VoronoiGridGenerator v("stoma.txt");
	v.grid_to_file("v_stoma");
	v.grid_to_dot("v_stoma");

	return 0;
}
*/

