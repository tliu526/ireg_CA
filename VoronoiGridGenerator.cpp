/*
Implementation of the Voronoi Grid Generator. Actual implementation may use Fortune's Algorithm.
Currently, the Voronoi diagram is built by reading in the data file generated by the Delaunay
Grid Generator.


(c) 2015 Tony Liu.
*/

#include "VoronoiGridGenerator.h"

#include <fstream>
#include <sstream>
#include <iostream>
#include <cstdlib>
#include <algorithm>

using namespace std;

VoronoiGridGenerator::VoronoiGridGenerator(string file){
	init_from_file(file);
	//worries about overwriting rev_gen_pts_map
	init_maps();
}

void VoronoiGridGenerator::init_from_file(string file){
	string line, name, coord, neighbor;
	int n;
	bool isAlive;
	istringstream iss;
	ifstream in(file);
	
	/**** GEN POINTS ****/
	getline(in, line);

	iss.str(line);
	iss.clear();
	iss >> name >> n;

	//TODO attributes, this line is ignored for now
	getline(in, line);

	for (int i = 0; i < n; i++){
		getline(in,line);
		iss.str(line);
		iss.clear();

		iss >> name >> coord >> isAlive;

		//TODO attribute list
		/*
	    while(n){
	        iss >> attr;
	        //do something
	    }
		*/

		//TODO something's up with mingw
		//float x = stof(coord.substr(0, coord.find(","));
		//float y = stof(coord.substr(coord.find(",")+1, coord.size());

		float x = atof(coord.substr(0, coord.find(",")).c_str());
		float y = atof(coord.substr(coord.find(",")+1, coord.size()).c_str());

		Point p(x,y);
		gen_pts.push_back(p);
		pt_map[name] = p;
		rev_gen_pt_map[p] = name;
		graph.add_vertex(name, Cell(p, name, isAlive));

	    /*
		while(!iss.eof()){
			iss >> neighbor;
			//cout << neighbor << " ";
		}
        */
	}

	getline(in, line);
	
	/**** VERTS ****/
	getline(in, line);
	iss.str(line);
	iss.clear();
	iss >> name >> n;

	for (int i = 0; i < n; i++){
		getline(in, line);
		iss.str(line);
		iss.clear();

		iss >> name >> coord;

		float x = atof(coord.substr(0, coord.find(",")).c_str());
		float y = atof(coord.substr(coord.find(",")+1, coord.size()).c_str());

		Point p(x,y);

		//verts.push_back(p);
		pt_map[name] = p;
		rev_vert_map[p] = name;
	}

	getline(in, line);

	/**** EDGES ****/
	string p, q;
	getline(in, line);
	
	iss.str(line);
	iss.clear();
	iss >> name >> n;

	for(int i = 0; i < n; i++){
		getline(in, line);
		iss.str(line);
		iss.clear();

		iss >> name >> p >> q;
		Edge e(pt_map[p], pt_map[q]);
		edges.push_back(e);
		edge_map[name] = e;
		rev_edge_map[e] = name;

		graph.add_edge(rev_gen_pt_map[pt_map[p]], rev_gen_pt_map[pt_map[q]]);
	}

	getline(in, line);

	/**** FACES ****/
	string e1, e2, e3;
	getline(in, line);
	iss.str(line);
	iss.clear();
	iss >> name >> n;

	for (int i = 0; i < n; i++){
		getline(in, line);
		iss.str(line);
		iss.clear();
		iss >> name >> e1 >> e2 >> e3;

		Tri t(edge_map[e1], edge_map[e2], edge_map[e3]);
		tri_map[name] = t;

		for (int i = 0; i < t.edges.size(); i++){
			Edge e = t.edges[i];
			//want the point or the label of the point?
			vector<string> *p_vec = &pt_face_map[rev_vert_map[e.p]];
			vector<string> *q_vec = &pt_face_map[rev_vert_map[e.q]];
			
			if(count(p_vec->begin(), p_vec->end(), name) == 0){
				p_vec->push_back(name);				
			}

			if(count(q_vec->begin(), q_vec->end(), name) == 0){
				q_vec->push_back(name);				
			}
		}
	}

	//Now, build up voronoi diagram from circumcenters of triangles
	init_voronoi();
}

void VoronoiGridGenerator::init_voronoi(){
	vector<Edge> new_edges;

	typename map<string, vector<string> >::iterator map_it;
	for(map_it = pt_face_map.begin(); map_it != pt_face_map.end(); map_it++){

		vector<string> adj_faces = map_it->second;
		vector<Edge> face_edges;

		for(int i = 0; i < adj_faces.size(); i++){
			Tri t1 = tri_map[adj_faces[i]];
			Point v1 = get_circumcenter(t1);

			if(count(verts.begin(), verts.end(), v1) == 0){
				verts.push_back(v1);
			}

			//build up the edges of the Voronoi polygon
			for(int j = 0; j < adj_faces.size(); j++){
				if(i != j){
					Tri t2 = tri_map[adj_faces[j]];	
					if(t2.shares_edge(t1)){
						Point v2 = get_circumcenter(t2);
						Edge e(v1, v2);

						if(count(face_edges.begin(), face_edges.end(), e) == 0){
							face_edges.push_back(e);
						}
					}
				}
			}
		}

		for(int i = 0; i < face_edges.size(); i++){
			if(count(new_edges.begin(), new_edges.end(), face_edges[i]) == 0){
				new_edges.push_back(face_edges[i]);
			}
		}

		faces.push_back(Poly(face_edges));
	}
	
	edges.clear();
	edges = new_edges;
	edge_map.clear();
	rev_edge_map.clear();
	pt_map.clear();
	rev_vert_map.clear();
}

void VoronoiGridGenerator::generate_graph(){}

int main(){
	/*
	Point p1(0,0);
	Point p2(0,1);
	Point p3(1,0);
	Point p4(0,-1);

	Tri t1(Edge(p1,p2),Edge(p2,p3), Edge(p1,p3));
	Tri t2(Edge(p1,p2),Edge(p2,p4), Edge(p1,p4));

	cout << t1 << endl;
	cout << t2 << endl;

	cout << t1.shares_edge(t2) << endl;
	return 0;
	*/
	
	VoronoiGridGenerator v("test.txt");
	v.grid_to_file("vtest.txt");
	v.grid_to_dot("vtest");
}