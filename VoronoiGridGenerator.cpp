/*
Implementation of the Voronoi Grid Generator. Actual implementation may use Fortune's Algorithm.
Currently, the Voronoi diagram is built by reading in the data file generated by the Delaunay
Grid Generator.


(c) 2015 Tony Liu.
*/

#include "VoronoiGridGenerator.h"

#include <fstream>
#include <sstream>
#include <iostream>
#include <cstdlib>

using namespace std;

VoronoiGridGenerator::VoronoiGridGenerator(string file){
	init_from_file(file);
	init_voronoi();
}

void VoronoiGridGenerator::init_from_file(string file){
	string line, name, coord, neighbor;
	int count;
	bool isAlive;
	istringstream iss;
	ifstream in(file);
	
	/**** POINTS ****/
	getline(in, line);

	iss.str(line);
	iss.clear();
	iss >> name >> count;

	//TODO attributes, this line is ignored for now
	getline(in, line);

	for (int i = 0; i < count; i++){
		getline(in,line);
		iss.str(line);
		iss.clear();

		iss >> name >> coord >> isAlive;

		//TODO attribute list
		/*
	    while(count){
	        iss >> attr;
	        //do something
	    }
		*/

		//TODO something's up with mingw
		//float x = stof(coord.substr(0, coord.find(","));
		//float y = stof(coord.substr(coord.find(",")+1, coord.size());

		float x = atof(coord.substr(0, coord.find(",")).c_str());
		float y = atof(coord.substr(coord.find(",")+1, coord.size()).c_str());

		Point p(x,y);
		gen_pts.push_back(p);
		pt_map[name] = p;
		rev_pt_map[p] = name;
		graph.add_vertex(name, Cell(p, name, isAlive));

	    /*
		while(!iss.eof()){
			iss >> neighbor;
			//cout << neighbor << " ";
		}
        */
	}

	getline(in, line);
	
	/**** EDGES ****/
	string p, q;
	getline(in, line);
	
	iss.str(line);
	iss.clear();
	iss >> name >> count;

	for(int i = 0; i < count; i++){
		getline(in, line);
		iss.str(line);
		iss.clear();

		iss >> name >> p >> q;
		Edge e(pt_map[p], pt_map[q]);
		edges.push_back(e);
		edge_map[name] = e;
		rev_edge_map[e] = name;
		graph.add_edge(p, q);
	}

	getline(in, line);

	/**** FACES ****/
	string e1, e2, e3;
	getline(in, line);
	iss.str(line);
	iss.clear();
	iss >> name >> count;

	for (int i = 0; i < count; i++){
		getline(in, line);
		iss.str(line);
		iss.clear();
		iss >> name >> e1 >> e2 >> e3;

		Tri t(edge_map[e1], edge_map[e2], edge_map[e3]);
		tri_map[name] = t;

		for (int i = 0; i < t.edges.size(); i++){
			Edge e = t.edges[i];
			//want the point or the label of the point?
			pt_face_map[rev_pt_map[e.p]].push_back(name);
			pt_face_map[rev_pt_map[e.q]].push_back(name);
		}
	}
}

void VoronoiGridGenerator::init_voronoi(){
	vector<Edge> new_edges;

	typename map<string, vector<string> >::iterator map_it;
	for(map_it = pt_face_map.begin(); map_it != pt_face_map.end(); map_it++){

		vector<string> adj_faces = map_it->second;
		vector<Edge> face_edges;

		for(int i = 0; i < adj_faces.size(); i++){
			Tri t1 = tri_map[adj_faces[i]];
			Point v1 = get_circumcenter(t1);

			verts.push_back(v1);

			for(int j = 0; j < adj_faces.size(); j++){
				if(i != j){
					Tri t2 = tri_map[adj_faces[j]];	
					if(t2.shares_edge(t1)){
						Point v2 = get_circumcenter(t2);
						face_edges.push_back(Edge(v1, v2));
						break;
					}
				}
			}
		}
		new_edges.insert(new_edges.end(), face_edges.begin(), face_edges.end());
		faces.push_back(Poly(face_edges));

	}
	edges = new_edges;
	edge_map.clear();
	rev_edge_map.clear();
	//pt_map.clear();
	//rev_pt_map.clear();
}

void VoronoiGridGenerator::generate_graph(){}

int main(){
	Point p1(0,0);
	Point p2(0,1);
	Point p3(1,0);
	Point p4(0,-1);

	Tri t1(Edge(p1,p2),Edge(p2,p3), Edge(p1,p3));
	Tri t2(Edge(p1,p2),Edge(p2,p4), Edge(p1,p4));

	cout << t1 << endl;
	cout << t2 << endl;

	cout << t1.shares_edge(t2) << endl;
	return 0;

	VoronoiGridGenerator v("test.txt");
	//v.grid_to_file("vtest.txt");
}