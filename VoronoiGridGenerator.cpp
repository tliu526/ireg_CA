/*
Implementation of the Voronoi Grid Generator. Actual implementation may use Fortune's Algorithm.
Currently, the Voronoi diagram is built by reading in the data file generated by the Delaunay
Grid Generator.


(c) 2015 Tony Liu.
*/

#include "VoronoiGridGenerator.h"

#include <fstream>
#include <sstream>
#include <iostream>
#include <cstdlib>
#include <algorithm>

using namespace std;

VoronoiGridGenerator::VoronoiGridGenerator(string file){
	grid_type = "Voronoi";
	init_from_file(file);
	
	//worries about overwriting rev_gen_pts_map
	init_maps();
}

void VoronoiGridGenerator::init_from_file(string file){
	string line, name, coord, neighbor;
	int n;
	bool isAlive;
	istringstream iss;
	ifstream in(file);
	
	/**** BOUNDARY ****/
	getline(in, line);
	iss.str(line);
	iss.clear();
	iss >> name;

	if(name.compare("Delaunay") != 0){
		throw "Incorrect input file, Delaunay needed";
	}

	iss >> min_x >> max_x >> min_y >> max_y;	

	cout << "min_x: " << min_x << endl;
	cout << "max_x: " << max_x << endl;
	cout << "min_y: " << min_y << endl;
	cout << "max_y: " << max_y << endl;

	/**** GEN POINTS ****/
	getline(in, line);

	iss.str(line);
	iss.clear();
	iss >> name >> n;

	//TODO attributes, this line is ignored for now
	getline(in, line);

	for (int i = 0; i < n; i++){
		getline(in,line);
		iss.str(line);
		iss.clear();

		iss >> name >> coord >> isAlive;

		//TODO attribute list
		/*
	    while(n){
	        iss >> attr;
	        //do something
	    }
		*/

		//TODO something's up with mingw
		//float x = stof(coord.substr(0, coord.find(","));
		//float y = stof(coord.substr(coord.find(",")+1, coord.size());

		float x = atof(coord.substr(0, coord.find(",")).c_str());
		float y = atof(coord.substr(coord.find(",")+1, coord.size()).c_str());

		Point p(x,y);
		gen_pts.push_back(p);
		pt_map[name] = p;
		rev_gen_pt_map[p] = name;
		graph.add_vertex(name, Cell(p, name, isAlive));

	    /*
		while(!iss.eof()){
			iss >> neighbor;
			//cout << neighbor << " ";
		}
        */
	}

	getline(in, line);
	
	/**** VERTS ****/
	getline(in, line);
	iss.str(line);
	iss.clear();
	iss >> name >> n;

	for (int i = 0; i < n; i++){
		getline(in, line);
		iss.str(line);
		iss.clear();

		iss >> name >> coord;

		float x = atof(coord.substr(0, coord.find(",")).c_str());
		float y = atof(coord.substr(coord.find(",")+1, coord.size()).c_str());

		Point p(x,y);

		//verts.push_back(p);
		pt_map[name] = p;
		rev_vert_map[p] = name;
	}

	getline(in, line);

	/**** EDGES ****/
	string p, q;
	getline(in, line);
	
	iss.str(line);
	iss.clear();
	iss >> name >> n;

	for(int i = 0; i < n; i++){
		getline(in, line);
		iss.str(line);
		iss.clear();

		iss >> name >> p >> q;
		Edge e(pt_map[p], pt_map[q]);
		edges.push_back(e);
		edge_map[name] = e;
		rev_edge_map[e] = name;

		graph.add_edge(rev_gen_pt_map[pt_map[p]], rev_gen_pt_map[pt_map[q]]);
	}

	getline(in, line);

	/**** FACES ****/
	string e1, e2, e3;
	getline(in, line);
	iss.str(line);
	iss.clear();
	iss >> name >> n;

	for (int i = 0; i < n; i++){
		getline(in, line);
		iss.str(line);
		iss.clear();
		iss >> name >> e1 >> e2 >> e3;

		Tri t(edge_map[e1], edge_map[e2], edge_map[e3]);
		tri_map[name] = t;

		for (int i = 0; i < t.edges.size(); i++){
			Edge e = t.edges[i];
			//want the point or the label of the point?
			vector<string> *p_vec = &pt_face_map[rev_vert_map[e.p]];
			vector<string> *q_vec = &pt_face_map[rev_vert_map[e.q]];
			
			if(count(p_vec->begin(), p_vec->end(), name) == 0){
				p_vec->push_back(name);				
			}

			if(count(q_vec->begin(), q_vec->end(), name) == 0){
				q_vec->push_back(name);				
			}
		}
	}

	//Now, build up voronoi diagram from circumcenters of triangles
	init_borders();
	init_voronoi();

}

void VoronoiGridGenerator::init_borders(){
	top_border = Edge(Point(min_x, max_y), Point(max_x, max_y));
	bottom_border = Edge(Point(min_x, min_y), Point(max_x, min_y));
	left_border = Edge(Point(min_x, min_y), Point(min_x, max_y));
	right_border = Edge(Point(max_x, min_y), Point(max_x, max_y));
}

void VoronoiGridGenerator::init_voronoi(){
	vector<Edge> new_edges;

	typename map<string, vector<string> >::iterator map_it;
	for(map_it = pt_face_map.begin(); map_it != pt_face_map.end(); map_it++){

		vector<string> adj_faces = map_it->second;
		vector<Edge> face_edges;

		for(int i = 0; i < adj_faces.size(); i++){
			Tri t1 = tri_map[adj_faces[i]];
			/*
			Point v1 = clamp_pt(get_circumcenter(t1));
			if(count(verts.begin(), verts.end(), v1) == 0){
				verts.push_back(v1);
			}
	        */
			Point v1 = get_circumcenter(t1);
			
			//build up the edges of the Voronoi polygon
			for(int j = 0; j < adj_faces.size(); j++){
				if(i != j){
					Tri t2 = tri_map[adj_faces[j]];	
					if(t2.shares_edge(t1)){
						//Point v2 = clamp_pt(get_circumcenter(t2));
						Point v2 = get_circumcenter(t2);
						Edge e = clamp_edge(Edge(v1, v2));
						if(e.p != e.q){
							if(count(verts.begin(), verts.end(), e.p) == 0){
								verts.push_back(e.p);
							}

							if(count(verts.begin(), verts.end(), e.q) == 0){
								verts.push_back(e.q);
							}						

							if(count(face_edges.begin(), face_edges.end(), e) == 0){
								face_edges.push_back(e);
							}
						}
					}
				}
			}
		}

		add_border_edge(face_edges);

		for(int i = 0; i < face_edges.size(); i++){
			if(count(new_edges.begin(), new_edges.end(), face_edges[i]) == 0){
				new_edges.push_back(face_edges[i]);
			}
		}

		faces.push_back(Poly(face_edges));
	}

	edges.clear();
	edges = new_edges;
	edge_map.clear();
	rev_edge_map.clear();
	pt_map.clear();
	rev_vert_map.clear();
}

//TODO instead of a straight clamp, calculate equation for line and then clamp at border
Point VoronoiGridGenerator::clamp_pt(Point p){
	float x, y;
	
	x = max(min(max_x+100, p.x), min_x-100);
	y = max(min(max_y+100, p.y), min_y-100);

	return Point(x,y);
}

Edge VoronoiGridGenerator::clamp_edge(Edge e){
	//case 1: both ends in boundary
	if(pt_in_grid(e.q) && pt_in_grid(e.p)){
		return e;
	}
	//case 2: one end in boundary
	else if(pt_in_grid(e.q) || pt_in_grid(e.p)){
		Point border_pt;
		pair<float, float> line_params;
		line_params = (get_line(e.q, e.p));

		if(edge_intersect(top_border, e)) border_pt = eval_at_border(line_params, top_border);
		else if(edge_intersect(bottom_border, e)) border_pt = eval_at_border(line_params, bottom_border);
		else if(edge_intersect(left_border, e)) border_pt = eval_at_border(line_params, left_border);
		else if(edge_intersect(right_border, e)) border_pt = eval_at_border(line_params, right_border);

		if(pt_in_grid(e.q)){
			return Edge(e.q, border_pt);
		}
		else {
			return Edge(e.p, border_pt);
		}
	}
	//case 3: both ends out of the boundary
	else {
		Point border_pt;
		pair<float, float> line_params;
		line_params = (get_line(e.q, e.p));
		border_pt = eval_at_border(line_params, closest_border(e));
		return Edge(border_pt, border_pt); //we're returning a self edge
	}
}

void VoronoiGridGenerator::add_border_edge(vector<Edge> &edges){
	Point *p1 = NULL;
	Point *p2 = NULL;
	for(int i = 0; i < edges.size(); i++){
		Edge e = edges[i];
		if(!pt_in_grid(e.p)){
			p1 = &e.p;
			break;
		}

		if(!pt_in_grid(e.q)){
			p1 = &e.q;
			break;
		}
	}
	if(p1 != NULL){
		for(int i = 0; i < edges.size(); i++){
			Edge e = edges[i];
			if((e.p != *p1) && !pt_in_grid(e.p)){
				p2 = &e.p;
				break;
			}

			if((e.q != *p1) && !pt_in_grid(e.q)){
				p2 = &e.q;
				break;
			}
		}
		if(p2 != NULL){
			edges.push_back(Edge(*p1,*p2));
		}
	}	
}

//pre: border is one of the grid borders
Point VoronoiGridGenerator::eval_at_border(pair<float, float> line_params, Edge border) {
	//L/R border
	if(border.p.x == border.q.x){
		float y = (line_params.first * border.p.x) + line_params.second;
		return Point(border.p.x, y);
	}
	//T/D border
	else {
		float x = (border.p.y - line_params.second) / line_params.first;
		return Point(x, border.p.y);
	}
	
}

//pre: Edge e has both points outside the grid
Edge VoronoiGridGenerator::closest_border(Edge e){
	if((e.q.y > max_y) && (e.p.y > max_y)) return top_border;
	if((e.q.y < min_y) && (e.p.y < min_y)) return bottom_border;
	if((e.q.x < min_x) && (e.p.x < min_x)) return left_border;
	if((e.q.x > max_x) && (e.p.x > max_x)) return right_border;

	//shouldn't get here
	return top_border;
}

void VoronoiGridGenerator::generate_graph(){}

int main(){
	/*
	Point p1(0,0);
	Point p2(0,1);
	Point p3(1,0);
	Point p4(0,-1);

	Tri t1(Edge(p1,p2),Edge(p2,p3), Edge(p1,p3));
	Tri t2(Edge(p1,p2),Edge(p2,p4), Edge(p1,p4));

	cout << t1 << endl;
	cout << t2 << endl;

	cout << t1.shares_edge(t2) << endl;
	return 0;
	*/
	
	VoronoiGridGenerator v("test.txt");
	v.grid_to_file("vtest.txt");
	v.grid_to_dot("vtest");
}